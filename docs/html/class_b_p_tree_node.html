<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>B+tree: BPTreeNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B+tree
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">An in-memory implementation of the B+ tree in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_b_p_tree_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BPTreeNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_b_p_tree_node_8h_source.html">BPTreeNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14311604a645bff7161627e5eb0fac7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a14311604a645bff7161627e5eb0fac7b">BPTreeNode</a> (int, bool)</td></tr>
<tr class="separator:a14311604a645bff7161627e5eb0fac7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d973d5e9ce09214498534dfc99819f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a5d973d5e9ce09214498534dfc99819f8">BPTreeNode</a> (int, bool, <a class="el" href="class_b_p_tree_node_element.html">BPTreeNodeElement</a> *)</td></tr>
<tr class="separator:a5d973d5e9ce09214498534dfc99819f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e11538810d2560d58068a09b034eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a54e11538810d2560d58068a09b034eb6">getState</a> ()</td></tr>
<tr class="separator:a54e11538810d2560d58068a09b034eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7f2c9bd1573abbc4b23c7fd9b92634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#aaf7f2c9bd1573abbc4b23c7fd9b92634">setFilled</a> (int)</td></tr>
<tr class="separator:aaf7f2c9bd1573abbc4b23c7fd9b92634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58564fb9113c66a47d5e628abc00d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#aa58564fb9113c66a47d5e628abc00d57">getNext</a> ()</td></tr>
<tr class="separator:aa58564fb9113c66a47d5e628abc00d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5eff3442df967805c2bf5ae572c4bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#ada5eff3442df967805c2bf5ae572c4bd">getPrev</a> ()</td></tr>
<tr class="separator:ada5eff3442df967805c2bf5ae572c4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e18a7fc68cb2676fffb78492f074199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a5e18a7fc68cb2676fffb78492f074199">setNext</a> (<a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *)</td></tr>
<tr class="separator:a5e18a7fc68cb2676fffb78492f074199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ad55dfe13386d3dc516b29d7cfd02f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#ac6ad55dfe13386d3dc516b29d7cfd02f">setPrev</a> (<a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *)</td></tr>
<tr class="separator:ac6ad55dfe13386d3dc516b29d7cfd02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9916da8fe90f8ee449a91f8d92dd98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a9f9916da8fe90f8ee449a91f8d92dd98">isOverflow</a> ()</td></tr>
<tr class="separator:a9f9916da8fe90f8ee449a91f8d92dd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0ef1378a75cb537998a51ac2289b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a6e0ef1378a75cb537998a51ac2289b6f">insert</a> (double, string, stack&lt; <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * &gt; &amp;, <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&amp;)</td></tr>
<tr class="separator:a6e0ef1378a75cb537998a51ac2289b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b80b2d69530b73739b5233a64926c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a7b80b2d69530b73739b5233a64926c59">insert</a> (<a class="el" href="class_b_p_tree_node_element.html">BPTreeNodeElement</a> *, stack&lt; <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * &gt; &amp;, <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&amp;)</td></tr>
<tr class="separator:a7b80b2d69530b73739b5233a64926c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72661772b56bc85ea6f6f5a63b34e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#ac72661772b56bc85ea6f6f5a63b34e43">splitNode</a> (stack&lt; <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * &gt; &amp;, <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&amp;)</td></tr>
<tr class="separator:ac72661772b56bc85ea6f6f5a63b34e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fce301114821d03bb2de8ac2336f9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a4fce301114821d03bb2de8ac2336f9c7">search</a> (double, vector&lt; string &gt; &amp;)</td></tr>
<tr class="separator:a4fce301114821d03bb2de8ac2336f9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6df489df490198ca2eb069de27c1df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a9b6df489df490198ca2eb069de27c1df">rangeSearch</a> (double, double, vector&lt; string &gt; &amp;)</td></tr>
<tr class="separator:a9b6df489df490198ca2eb069de27c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a47c3cdb0020bc013b489dc8451ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a53a47c3cdb0020bc013b489dc8451ea4">leafSanityCheck</a> ()</td></tr>
<tr class="separator:a53a47c3cdb0020bc013b489dc8451ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378b389e54f86622f1c130fca4a699c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_p_tree_node.html#a378b389e54f86622f1c130fca4a699c0">findPosition</a> (double)</td></tr>
<tr class="separator:a378b389e54f86622f1c130fca4a699c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a14311604a645bff7161627e5eb0fac7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BPTreeNode::BPTreeNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t_isLeaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Class defining the individual nods of the B+ tree. Each of these nodes has an array of key objects ( <a class="el" href="class_b_p_tree_node_element.html">BPTreeNodeElement</a> ) </p>
<p>true if it is a leaf node or false otherwise</p>
<p>order of the B+ tree</p>
<p>determines how much of the array of key objects is filled</p>
<p>array of key objects of length (order + 1) </p>

</div>
</div>
<a class="anchor" id="a5d973d5e9ce09214498534dfc99819f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BPTreeNode::BPTreeNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t_isLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node_element.html">BPTreeNodeElement</a> *&#160;</td>
          <td class="paramname"><em>t_keyNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternate constructor to initialize Node when splitting occurs. This constructor allows us to predefine the key values </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a378b389e54f86622f1c130fca4a699c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * BPTreeNode::findPosition </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility method to find position of a key object in an array of key objects </p>

</div>
</div>
<a class="anchor" id="aa58564fb9113c66a47d5e628abc00d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * BPTreeNode::getNext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Getter for next pointer. </p>

</div>
</div>
<a class="anchor" id="ada5eff3442df967805c2bf5ae572c4bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * BPTreeNode::getPrev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Getter for previous pointer </p>

</div>
</div>
<a class="anchor" id="a54e11538810d2560d58068a09b034eb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e0ef1378a75cb537998a51ac2289b6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::insert </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack&lt; <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert procedure to search for leaf top down and insert (double, string) key value. The root to leaf nodes are stored in a stack and are used for bottom up recursive insert if needed after node spits </p>

</div>
</div>
<a class="anchor" id="a7b80b2d69530b73739b5233a64926c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node_element.html">BPTreeNodeElement</a> *&#160;</td>
          <td class="paramname"><em>keyElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack&lt; <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert procedure to recursively insert bottom up when a node splits </p>

</div>
</div>
<a class="anchor" id="a9f9916da8fe90f8ee449a91f8d92dd98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BPTreeNode::isOverflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To determine if the node is overflowing and a split is needed </p>

</div>
</div>
<a class="anchor" id="a53a47c3cdb0020bc013b489dc8451ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::leafSanityCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b6df489df490198ca2eb069de27c1df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::rangeSearch </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Range search procedure for B+ tree. Returns all (key, value) pairs with key in [key1, key2] </p>

</div>
</div>
<a class="anchor" id="a4fce301114821d03bb2de8ac2336f9c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::search </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search procedure for B+ tree. Traverse top down to leaf from root </p>

</div>
</div>
<a class="anchor" id="aaf7f2c9bd1573abbc4b23c7fd9b92634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::setFilled </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setter to update / set how much of the keys array is filled </p>

</div>
</div>
<a class="anchor" id="a5e18a7fc68cb2676fffb78492f074199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::setNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&#160;</td>
          <td class="paramname"><em>t_next</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setter for next pointer. Useful only in leaf nodes (maintaining a doubly linked list) </p>

</div>
</div>
<a class="anchor" id="ac6ad55dfe13386d3dc516b29d7cfd02f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::setPrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&#160;</td>
          <td class="paramname"><em>t_prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setter for previous pointer. Useful only for leaf nodes </p>

</div>
</div>
<a class="anchor" id="ac72661772b56bc85ea6f6f5a63b34e43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPTreeNode::splitNode </td>
          <td>(</td>
          <td class="paramtype">stack&lt; <a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_p_tree_node.html">BPTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split procedure called when a node overflows. It is cut into 2. If a node is leaf the right child includes the center, else it does not Also if the root to leaf path stack is empty it means that a new root is created, so update external root pointer to tree Else if stack is not empty recursively insert the newly created center key object into nodes from path stack bottom up </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>includes/<a class="el" href="_b_p_tree_node_8h_source.html">BPTreeNode.h</a></li>
<li>classes/<a class="el" href="_b_p_tree_node_8cpp.html">BPTreeNode.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
